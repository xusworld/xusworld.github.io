<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xusworld.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux中最重要的概念就是进程，而进程中最基本的概念就是进程描述符。本文结合Linux-2.6.12源码和《深入理解Linux内核》一书中精彩的讲述，深入介绍Linux源码中第一个概念——进程描述符 task_struct。">
<meta property="og:type" content="article">
<meta property="og:title" content="进程描述符">
<meta property="og:url" content="https://xusworld.github.io/2021/08/23/linux-task-struct/index.html">
<meta property="og:site_name" content="Tatooine">
<meta property="og:description" content="Linux中最重要的概念就是进程，而进程中最基本的概念就是进程描述符。本文结合Linux-2.6.12源码和《深入理解Linux内核》一书中精彩的讲述，深入介绍Linux源码中第一个概念——进程描述符 task_struct。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-23T09:34:16.000Z">
<meta property="article:modified_time" content="2021-08-23T10:47:36.928Z">
<meta property="article:author" content="xusworld">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Linux Kernel">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xusworld.github.io/2021/08/23/linux-task-struct/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程描述符 | Tatooine</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tatooine</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xusworld" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xusworld.github.io/2021/08/23/linux-task-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xusworld">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tatooine">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程描述符
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-23 17:34:16 / 修改时间：18:47:36" itemprop="dateCreated datePublished" datetime="2021-08-23T17:34:16+08:00">2021-08-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-Kernel/" itemprop="url" rel="index"><span itemprop="name">Linux Kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Linux中最重要的概念就是进程，而进程中最基本的概念就是进程描述符。本文结合<code>Linux-2.6.12</code>源码和《深入理解Linux内核》一书中精彩的讲述，深入介绍Linux源码中第一个概念——进程描述符 task_struct。</p>
<span id="more"></span>

<hr>
<p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。例如，内核必须知道进程的优先级，它是正在CPU上运行还是因某些事件而被阻塞，给它分配什么样的地址空间，允许它访问哪个文件等。这正是进程描述符（process descriptor）的作用——进程描述符是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。因为进程描述符包含了很多进程属性信息，所以结构相当复杂。</p>
<h2 id="1-task-struct-结构体"><a href="#1-task-struct-结构体" class="headerlink" title="1 task_struct 结构体"></a>1 task_struct 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">=============== include/linux/sched.h ===============</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">  <span class="comment">// 进程状态</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进程基本信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">thread_info</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进程描述符使用计数，被置为2时，表示进程描述符正在被使用而且其相应的进程处于活动状态</span></span><br><span class="line">	<span class="keyword">atomic_t</span> usage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   flags是进程当前的状态标志(注意和运行状态区分)</span></span><br><span class="line"><span class="comment">        1) #define PF_ALIGNWARN    0x00000001: 显示内存地址未对齐警告</span></span><br><span class="line"><span class="comment">        2) #define PF_PTRACED    0x00000010: 标识是否是否调用了ptrace</span></span><br><span class="line"><span class="comment">        3) #define PF_TRACESYS    0x00000020: 跟踪系统调用</span></span><br><span class="line"><span class="comment">        4) #define PF_FORKNOEXEC 0x00000040: 已经完成fork，但还没有调用exec</span></span><br><span class="line"><span class="comment">        5) #define PF_SUPERPRIV    0x00000100: 使用超级用户(root)权限</span></span><br><span class="line"><span class="comment">        6) #define PF_DUMPCORE    0x00000200: dumped core</span></span><br><span class="line"><span class="comment">        7) #define PF_SIGNALED    0x00000400: 此进程由于其他进程发送相关信号而被杀死</span></span><br><span class="line"><span class="comment">        8) #define PF_STARTING    0x00000002: 当前进程正在被创建</span></span><br><span class="line"><span class="comment">        9) #define PF_EXITING    0x00000004: 当前进程正在关闭</span></span><br><span class="line"><span class="comment">        10) #define PF_USEDFPU    0x00100000: Process used the FPU this quantum(SMP only)</span></span><br><span class="line"><span class="comment">        #define PF_DTRACE    0x00200000: delayed trace (used on m68k)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ptrace系统调用，成员ptrace被设置为0时表示不需要被跟踪，它的可能取值如下：</span></span><br><span class="line"><span class="comment">        1) #define PT_PTRACED    0x00000001</span></span><br><span class="line"><span class="comment">        2) #define PT_DTRACE    0x00000002: delayed trace (used on m68k, i386)</span></span><br><span class="line"><span class="comment">        3) #define PT_TRACESYSGOOD    0x00000004</span></span><br><span class="line"><span class="comment">        4) #define PT_PTRACE_CAP    0x00000008: ptracer can follow suid-exec</span></span><br><span class="line"><span class="comment">        5) #define PT_TRACE_FORK    0x00000010</span></span><br><span class="line"><span class="comment">        6) #define PT_TRACE_VFORK    0x00000020</span></span><br><span class="line"><span class="comment">        7) #define PT_TRACE_CLONE    0x00000040</span></span><br><span class="line"><span class="comment">        8) #define PT_TRACE_EXEC    0x00000080</span></span><br><span class="line"><span class="comment">        9) #define PT_TRACE_VFORK_DONE    0x00000100</span></span><br><span class="line"><span class="comment">        10) #define PT_TRACE_EXIT    0x00000200</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于表示获取大内核锁的次数，如果进程未获得过锁，则置为-1</span></span><br><span class="line">	<span class="keyword">int</span> lock_depth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进程优先级</span></span><br><span class="line">	<span class="keyword">int</span> prio, static_prio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span></span><br><span class="line">	<span class="keyword">prio_array_t</span> *<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sleep_avg;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> timestamp, last_ran;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> sched_time; <span class="comment">/* sched_clock time spent running */</span></span><br><span class="line">	<span class="keyword">int</span> activated;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进程调度策略</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> policy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cpus_allowed是一个位域，在多处理器系统上使用，用于控制进程可以在哪里处理器上运行</span></span><br><span class="line">	<span class="keyword">cpumask_t</span> cpus_allowed;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice, first_time_slice;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">  <span class="comment">// 用于调度器统计进程的运行信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span> <span class="title">sched_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过list_head将当前进程的task_struct串联进内核的进程列表中，构建；linux进程链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ptrace_list/ptrace_children forms the list of my children</span></span><br><span class="line"><span class="comment">	 * that were stolen by a ptracer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_list</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  进程地址空间</span></span><br><span class="line">  <span class="comment">//  mm: 指向进程所拥有的内存描述符</span></span><br><span class="line">  <span class="comment">//  active_mm: active_mm指向进程运行时所使用的内存描述符</span></span><br><span class="line">  <span class="comment">//  对于普通进程而言，这两个指针变量的值相同。但是，内核线程不拥有任何内存描述符，所以它们的mm成员总是为NULL。当内核线程得以运行时，它的active_mm成员被初始化为前一个运行进程的active_mm值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* task state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出状态码</span></span><br><span class="line">	<span class="keyword">long</span> exit_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exit_code用于设置进程的终止代号，这个值要么是_exit()或exit_group()</span></span><br><span class="line">  <span class="comment">// 系统调用参数(正常终止)，要么是由内核提供的一个错误代号(异常终止)</span></span><br><span class="line">  <span class="comment">// exit_signal被置为-1时表示是某个线程组中的一员。只有当线程组的最后一个成员终止时，</span></span><br><span class="line">  <span class="comment">// 才会产生一个信号，以通知线程组的领头进程的父进程</span></span><br><span class="line">	<span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pdeath_signal用于判断父进程终止时发送信号</span></span><br><span class="line">	<span class="keyword">int</span> pdeath_signal;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于处理不同的ABI</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> personality;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// did_exec用于记录进程代码是否被execve()函数所执行</span></span><br><span class="line">	<span class="keyword">unsigned</span> did_exec:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进程ID</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="comment">// 线程组ID，同一个线程组拥有相同的pid，与领头线程(该组中第一个轻量级进程)pid一致，保存在tgid中，线程组领头线程的pid和tgid相同</span></span><br><span class="line">	<span class="keyword">pid_t</span> tgid;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pointers to (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">	 * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment">	 * p-&gt;parent-&gt;pid)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process (when being debugged) */</span></span><br><span class="line">  <span class="comment">// 指向父进程的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span>	<span class="comment">/* parent process */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * children/sibling forms the list of my children plus the</span></span><br><span class="line"><span class="comment">	 * tasks I&#x27;m ptracing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>	<span class="comment">/* list of my children */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>	<span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span>	<span class="comment">/* threadgroup leader */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>		<span class="comment">/* for vfork() */</span></span><br><span class="line">	<span class="keyword">int</span> __user *set_child_tid;		<span class="comment">/* CLONE_CHILD_SETTID */</span></span><br><span class="line">	<span class="keyword">int</span> __user *clear_child_tid;		<span class="comment">/* CLONE_CHILD_CLEARTID */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rt_priority;</span><br><span class="line">	<span class="keyword">cputime_t</span> utime, stime;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span></span><br><span class="line"><span class="comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">cputime_t</span> it_prof_expires, it_virt_expires;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> it_sched_expires;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>[3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">	<span class="keyword">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>   cap_effective, cap_inheritable, cap_permitted;</span><br><span class="line">	<span class="keyword">unsigned</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">thread_keyring</span>;</span>	<span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> oomkilladj; <span class="comment">/* OOM kill score adjustment (bit shift). */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 程序名</span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="keyword">int</span> link_count, total_link_count;</span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span></span><br><span class="line"><span class="comment">/* CPU-specific state of this task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向文件描述符的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line">  <span class="comment">// 指向打开文件的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">namespace</span> *<span class="title">namespace</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向进程的信号描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向进程的信号处理程序描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// blocked: 表示被阻塞信号的掩码</span></span><br><span class="line">  <span class="comment">// real_blocked: 表示临时掩码</span></span><br><span class="line">	<span class="keyword">sigset_t</span> blocked, real_blocked;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存放私有挂起信号的数据结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 信号处理程序备用堆栈的地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">  <span class="comment">// 表示堆栈的大小</span></span><br><span class="line">	<span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设备驱动程序常用notifier指向的函数来阻塞进程的某些信号</span></span><br><span class="line">	<span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line">  <span class="comment">//  otifier_data指的是notifier所指向的函数可能使用的数据</span></span><br><span class="line">	<span class="keyword">void</span> *notifier_data;</span><br><span class="line">  <span class="comment">// otifier_mask标识这些信号的位掩码</span></span><br><span class="line">	<span class="keyword">sigset_t</span> *notifier_mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span> *<span class="title">audit_context</span>;</span></span><br><span class="line">	<span class="keyword">seccomp_t</span> seccomp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread group tracking */</span></span><br><span class="line">   	u32 parent_exec_id;</span><br><span class="line">   	u32 self_exec_id;</span><br><span class="line"><span class="comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line"><span class="comment">/* Protection of proc_dentry: nesting proc_lock, dcache_lock, write_lock_irq(&amp;tasklist_lock); */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> proc_lock;</span><br><span class="line"><span class="comment">/* context-switch lock */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> switch_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* journalling filesystem info */</span></span><br><span class="line">	<span class="keyword">void</span> *journal_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* VM state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span> *<span class="title">reclaim_state</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_dentry</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存放块设备I/O数据流量信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// I/O调度器所使用的信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line">	<span class="keyword">siginfo_t</span> *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * current io wait handle: wait queue entry to use for io waits</span></span><br><span class="line"><span class="comment"> * If this thread is processing aio, this points at the waitqueue</span></span><br><span class="line"><span class="comment"> * inside the currently handled kiocb. It may be NULL (i.e. default</span></span><br><span class="line"><span class="comment"> * to a stack based synchronous wait) if its doing sync IO.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">wait_queue_t</span> *io_wait;</span><br><span class="line"><span class="comment">/* i/o counters(bytes read/written, #syscalls */</span></span><br><span class="line">	u64 rchar, wchar, syscr, syscw;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BSD_PROCESS_ACCT)</span></span><br><span class="line">	u64 acct_rss_mem1;	<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">	u64 acct_vm_mem1;	<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line">	<span class="keyword">clock_t</span> acct_stimexpd;	<span class="comment">/* clock_t-converted stime since last update */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">mempolicy</span>;</span></span><br><span class="line">	<span class="keyword">short</span> il_next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpuset</span> *<span class="title">cpuset</span>;</span></span><br><span class="line">	<span class="keyword">nodemask_t</span> mems_allowed;</span><br><span class="line">	<span class="keyword">int</span> cpuset_mems_generation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-核心字段"><a href="#2-核心字段" class="headerlink" title="2 核心字段"></a>2 核心字段</h2><h3 id="2-1-进程状态字段"><a href="#2-1-进程状态字段" class="headerlink" title="2.1 进程状态字段"></a>2.1 进程状态字段</h3><p>进程描述符中的state描述了进程所处的状态，state由一组宏定义组成，每个宏定义标识进程所处的一种状态，进程状态定义在 <code>inclucde/linux/sched.h</code>文件中，代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">=============== include/linux/sched.h ===============</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_TRACED		8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ZOMBIE		16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_DEAD		32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_task_state(tsk, state_value)		\</span></span><br><span class="line"><span class="meta">	do &#123; (tsk)-&gt;state = (state_value); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_task_state(tsk, state_value)		\</span></span><br><span class="line"><span class="meta">	set_mb((tsk)-&gt;state, (state_value))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_current_state(state_value)			\</span></span><br><span class="line"><span class="meta">	do &#123; current-&gt;state = (state_value); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_current_state(state_value)		\</span></span><br><span class="line"><span class="meta">	set_mb(current-&gt;state, (state_value))</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============== include/<span class="keyword">asm</span>-alpha/system.h ===============</span><br><span class="line"># set_mb</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_mb(var, value) \</span></span><br><span class="line"><span class="meta">do &#123; var = value; mb(); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mb() \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="meta-string">&quot;mb&quot;</span>: : :<span class="meta-string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="1-可运行状态-TASK-RUNNING-R状态"><a href="#1-可运行状态-TASK-RUNNING-R状态" class="headerlink" title="1 可运行状态(TASK_RUNNING) R状态"></a><strong>1 可运行状态(TASK_RUNNING) R状态</strong></h4><p>TASK_RUNNING 状态的进程是指正在CPU上执行的进程或者在运行队列中等待调度的进程。</p>
<h4 id="2-可中断的等待状态-TASK-INTERRUPTIBLE-S状态"><a href="#2-可中断的等待状态-TASK-INTERRUPTIBLE-S状态" class="headerlink" title="2 可中断的等待状态(TASK_INTERRUPTIBLE) S状态"></a><strong>2 可中断的等待状态(TASK_INTERRUPTIBLE) S状态</strong></h4><p>进程被挂起(睡眠)，直到某个条件变为真。一旦该条件为真，内核会设置进程的状态为 TASK_RUNNING。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都可以是可以唤醒进程的条件。（唤醒意味着进程的状态变为TASK_RUNNING）</p>
<h4 id="3-不可中断的等待状态-TASK-UNINTERRUPTIBLE-D状态"><a href="#3-不可中断的等待状态-TASK-UNINTERRUPTIBLE-D状态" class="headerlink" title="3 不可中断的等待状态(TASK_UNINTERRUPTIBLE) D状态"></a><strong>3 不可中断的等待状态(TASK_UNINTERRUPTIBLE) D状态</strong></h4><p>与TASK_INTERRUPTIBLE状态类似，但有一个特例，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的条件下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成前，设备驱动程序不能被中断。否则，硬件设备会处于不可预知的状态。与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。</p>
<h4 id="4-暂停状态-TASK-STOPPED-T状态"><a href="#4-暂停状态-TASK-STOPPED-T状态" class="headerlink" title="4 暂停状态(TASK_STOPPED) T状态"></a><strong>4 暂停状态(TASK_STOPPED) T状态</strong></h4><p>进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后，进入暂停状态。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。</p>
<h4 id="5-跟踪状态-TASK-TRACED-T状态"><a href="#5-跟踪状态-TASK-TRACED-T状态" class="headerlink" title="5 跟踪状态(TASK_TRACED) T状态"></a><strong>5 跟踪状态(TASK_TRACED) T状态</strong></h4><p>进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时，任何信号都可以把这个进程置于TASK_TRACED状态。当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p>
<p>对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停    下来。而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。</p>
<h4 id="6-僵死状态-EXIT-ZOMBIE"><a href="#6-僵死状态-EXIT-ZOMBIE" class="headerlink" title="6 僵死状态(EXIT_ZOMBIE)"></a><strong>6 僵死状态(EXIT_ZOMBIE)</strong></h4><p>进程的执行被终止，但是，父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前，内核不能丢弃包含在死亡进程描述符中的数据，因为父进程可能还需要它。</p>
<h4 id="7-僵死撤销状态-EXIT-DEAD"><a href="#7-僵死撤销状态-EXIT-DEAD" class="headerlink" title="7 僵死撤销状态(EXIT_DEAD)"></a><strong>7 僵死撤销状态(EXIT_DEAD)</strong></h4><p>最终状态：由于父进程刚发出wait4()或waitpid()系统调用, 因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行wait()类系统调用，所以将进程的状态从僵死状态改为僵死撤销状态。进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。</p>
<p>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>
<p>操作系统使用 <code>set_task_state</code> 和 <code>set_current_state</code> 宏设置指定进程的状态和当前执行进程的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">=============== include/linux/sched.h ===============</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_task_state(tsk, state_value)		\</span></span><br><span class="line"><span class="meta">	do &#123; (tsk)-&gt;state = (state_value); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_task_state(tsk, state_value)		\</span></span><br><span class="line"><span class="meta">	set_mb((tsk)-&gt;state, (state_value))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __set_current_state(state_value)			\</span></span><br><span class="line"><span class="meta">	do &#123; current-&gt;state = (state_value); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_current_state(state_value)		\</span></span><br><span class="line"><span class="meta">	set_mb(current-&gt;state, (state_value))</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set_mb</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_mb(var, value) \</span></span><br><span class="line"><span class="meta">do &#123; var = value; mb(); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mb() \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(<span class="meta-string">&quot;mb&quot;</span>: : :<span class="meta-string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-线程描述符字段"><a href="#2-2-线程描述符字段" class="headerlink" title="2.2 线程描述符字段"></a>2.2 线程描述符字段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">=============== include/<span class="keyword">asm</span>-i386/thread_info.h ===============</span><br><span class="line">struct thread_info &#123;</span><br><span class="line">	struct task_struct	*task;		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>	*<span class="title">exec_domain</span>;</span>	<span class="comment">/* execution domain */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		status;		<span class="comment">/* thread-synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	__s32			preempt_count; <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;	<span class="comment">/* thread address space:</span></span><br><span class="line"><span class="comment">					 	   0-0xBFFFFFFF for user-thead</span></span><br><span class="line"><span class="comment">						   0-0xFFFFFFFF for kernel-thread</span></span><br><span class="line"><span class="comment">						*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>    <span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>           previous_esp;   <span class="comment">/* ESP of the previous stack in case</span></span><br><span class="line"><span class="comment">						   of nested (IRQ) stacks</span></span><br><span class="line"><span class="comment">						*/</span></span><br><span class="line">	__u8			supervisor_stack[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-进程调度策略字段"><a href="#2-3-进程调度策略字段" class="headerlink" title="2.3 进程调度策略字段"></a>2.3 进程调度策略字段</h3><p>policy表示进程的调度策略，目前主要有以下三种：</p>
<ul>
<li><code>SCHED_NORMAL</code> 用于普通进程，它们通过完全公平调度器来处理</li>
<li><code>SCHED_FIFO</code>  先来先服务调度，由实时调度类处理</li>
<li><code>SCHED_RR</code>  时间片轮转调度，由实时调度类处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=============== include/linux/sched.h ===============</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scheduling policies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_NORMAL		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_FIFO		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_RR		2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-进程标识字段"><a href="#2-4-进程标识字段" class="headerlink" title="2.4 进程标识字段"></a>2.4 进程标识字段</h3><p>一般来说，能够被独立调度的每个执行上下文都必须有它自己的进程描述符；因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的task_struct结构。</p>
<p>进程和进程进程描述符之间有非常严格的一一对应关系，这使得用32位的进程描述符地址表示进程非常方便。进程描述符指针指向这些地址，内核对进程的大部分引用都是通过进程描述符指针进行的。</p>
<p>另一方面，类Unix操作系统允许用户使用一个叫做进程描述符Process ID (PID)的整数标识进程，PID存放在进程描述符的pid字段中。PID被顺序编号，新创建进程的PID通常是前一个进程的PID + 1。不过，PID值有一个上线，当内核使用的PID达到这个上限值的时候就必须循环使用已经限制的小PID号。在缺省情况下，最大的PID号是32767；系统管理员可以通过往/proc/sys/kernel/pid_max文件中写入一个更小的值来减少PID的上限值，使PID的上限小于32767。在64位体系结构中，系统管理员可以把PID的上限扩大到4194303。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=============== include/linux/thread.h ===============</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This controls the default maximum pid allocated to a process</span></span><br><span class="line"><span class="comment"> * CONFIG_BASE_SMALL = 0, PID_MAX_DEFAULT 值为 32768</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A maximum of 4 million PIDs should be enough for a while:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_MAX_LIMIT (CONFIG_BASE_SMALL ? PAGE_SIZE * 8 : \</span></span><br><span class="line"><span class="meta">	(sizeof(long) &gt; 4 ? 4 * 1024 * 1024 : PID_MAX_DEFAULT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于循环使用PID编号，内核必须通过设置一个pidmap_array位图来表示当前已经分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中的pidmap_array位图存放在一个单独的页中。然而，在64位体系结构中，当内核分配了超过当前位图大小的PID号时，需要为PID位图增加更多的页。系统会一直保存这些页不被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">=============== kernel/pid.c ===============</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIDMAP_ENTRIES		((PID_MAX_LIMIT + 8*PAGE_SIZE - 1)/PAGE_SIZE/8)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PID-map pages start out as NULL, they get allocated upon</span></span><br><span class="line"><span class="comment"> * first use and are never deallocated. This way a low pid_max</span></span><br><span class="line"><span class="comment"> * value does not cause lots of bitmaps to be allocated, but</span></span><br><span class="line"><span class="comment"> * the scheme scales to up to 4 million PIDs, runtime.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> struct pidmap &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span> nr_free;</span><br><span class="line">	<span class="keyword">void</span> *page;</span><br><span class="line">&#125; <span class="keyword">pidmap_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pidmap_t</span> pidmap_array[PIDMAP_ENTRIES] =</span><br><span class="line">	 &#123; [ <span class="number">0</span> ... PIDMAP_ENTRIES<span class="number">-1</span> ] = &#123; ATOMIC_INIT(BITS_PER_PAGE), <span class="literal">NULL</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Linux引入线程组表示。一个线程组中所有的线程使用和该线程组的领头线程（thread group leader）相同的PID，也就是该组中第一个轻量级进程的PID，也就是该组中第一个轻量级进程的PID，它被存入进程描述符的tgid字段中。getpid()系统调用返回当前进程的tgid值而不是pid的值，因此，一个多线程应用的所有线程共享相同的PID。绝大多数进程都属于一个线程组，包含单一的成员；线程组的领头线程其tgid的值与pid的值相同，因而getpid()系统调用对这类进程所起的作用和一般进程是一样的。</p>
<h3 id="2-5-亲属关系字段"><a href="#2-5-亲属关系字段" class="headerlink" title="2.5 亲属关系字段"></a>2.5 亲属关系字段</h3><p>程序创建的进程具有父/子关系。如果一个进程创建多个子进程时，则子进程之间具有兄弟关系。在进程描述符中引入几个字段来表示这些关系，如下表所示。进程0和进程1是有内核创建的，稍后会解释，进程1（init进程）是所有进程的祖先。</p>
<ul>
<li>字段 <code>real_parent</code> : 指向创建了P的进程描述符，如果P的父进程不再存在，就指向进程1（init进程）的描述符（因此，如果用户运行了一个后台进程而且退出了shell，后台进程就会成为init进程的子进程）</li>
<li>字段 <code>parent</code>: 指向P的当前父进程（这种进程的子进程终止时，必须向父进程发信号）。它的值通常与real_parent一致，但偶尔也可以不同。例如，当另一个进程发出监控P的ptrace()系统调用请求时。</li>
<li>字段<code>children</code>：子进程链表的头部，链表中的所有元素都是P创建的子进程</li>
<li>字段<code>sibling</code>: 指向兄弟进程链表中的下一个元素或前一个元素的指针，这些兄弟进程的父进程都是P</li>
</ul>
<h3 id="2-6-进程组-线程组字段"><a href="#2-6-进程组-线程组字段" class="headerlink" title="2.6 进程组/线程组字段"></a>2.6 进程组/线程组字段</h3><ul>
<li>字段 <code>group_leader</code>: P所在进程组的领头进程的描述符指针</li>
<li>字段 <code>signal_pgrp</code>: P所在进程组的领头进程的PID</li>
<li>字段 <code>tgid</code>: P所在线程组的领头进程的PID</li>
<li>字段 <code>signal-&gt;session</code>: P的登录会话领头进程的PID</li>
<li>字段 <code>ptrace_children</code>: 链表的头，该链表包含所有被debugger程序跟踪的P的子进程</li>
<li>字段 <code>ptrace_list</code>: 指向所跟踪进程其实际父进程链表的前一个和下一个元素</li>
</ul>
<h3 id="2-7-进程链表字段"><a href="#2-7-进程链表字段" class="headerlink" title="2.7 进程链表字段"></a>2.7 进程链表字段</h3><p>进程链表把所有进程的描述符链接起来。每个task_struct结构都包含一个list_head类型的<code>tasks</code>字段，这个类型的prev和next字段分别指向前面和后面的task_struct元素。</p>
<p>进程链表的头是init_task描述符，它是所谓的0进程（process 0）或 swapper进程的进程描述符。init_task的tasks.prev字段指向链表中最后插入的进程描述符的tasks字段。</p>
<h3 id="2-8-TASK-RUNNING状态的进程链表"><a href="#2-8-TASK-RUNNING状态的进程链表" class="headerlink" title="2.8 TASK_RUNNING状态的进程链表"></a>2.8 TASK_RUNNING状态的进程链表</h3><p>当内核寻找一个新进程在CPU上运行时，必须只考虑可运行进程（状态为TASK_RUNNING的进程）。</p>
<p>早先的Linux版本把所有的可运行进程都放在同一个叫做运行队列（runqueue）的链表中，由于维持链表中的进程按优先级排序的开销过大，因此，早期的调度程序不得不为选择“最佳”可运行进程而扫描整个队列。Linux2.6实现的运行队列有所不同。其目的是让调度程序能在固定的时间内选出“最佳”可运行进程，与队列中可运行的进程数无关。</p>
<p>提高调度程序运行速度的诀窍是建立多个可运行进程链表，每种进程优先级对应一个不同的链表。每个task_struct描述符包含一个list_head类型的字段<code>run_list</code>。如果进程的优先权等于k（取值范围 0 ~ 139）, run_list字段把该进程链入优先权为k的可运行进程的链表中。此外，在多处理器系统中，每个PCU都有它自己的运行队列，即它自己的进程链表集。这是一个通过增加数据结构的复杂度来优化性能的典型例子：调度程序的操作效率确实提高了，但运行队列却为此而被拆分为140个不同的队列。</p>
<p>内核代码中，可以使用 <code>enqueue_task()</code>函数把进程描述符插入某个运行队列的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=============== kernel/sched.c ===============</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> enqueue_task(struct task_struct *p, <span class="keyword">prio_array_t</span> *<span class="built_in">array</span>)</span><br><span class="line">&#123;</span><br><span class="line">	sched_info_queued(p);</span><br><span class="line">	list_add_tail(&amp;p-&gt;run_list, <span class="built_in">array</span>-&gt;<span class="built_in">queue</span> + p-&gt;prio);</span><br><span class="line">	__set_bit(p-&gt;prio, <span class="built_in">array</span>-&gt;bitmap);</span><br><span class="line">	<span class="built_in">array</span>-&gt;nr_active++;</span><br><span class="line">	p-&gt;<span class="built_in">array</span> = <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>dequeue_task()</code>函数从运行队列中删除一个进程的描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=============== kernel/sched.c ===============</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> dequeue_task(struct task_struct *p, <span class="keyword">prio_array_t</span> *<span class="built_in">array</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">array</span>-&gt;nr_active--;</span><br><span class="line">	list_del(&amp;p-&gt;run_list);</span><br><span class="line">	<span class="keyword">if</span> (list_empty(<span class="built_in">array</span>-&gt;<span class="built_in">queue</span> + p-&gt;prio))</span><br><span class="line">		__clear_bit(p-&gt;prio, <span class="built_in">array</span>-&gt;bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Linux-Kernel/" rel="tag"># Linux Kernel</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/23/linux-desc/" rel="prev" title="探索 Linux 内核源码">
      <i class="fa fa-chevron-left"></i> 探索 Linux 内核源码
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/23/linux-wait-queue/" rel="next" title="等待队列">
      等待队列 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-task-struct-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">1 task_struct 结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5"><span class="nav-text">2 核心字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%AD%97%E6%AE%B5"><span class="nav-text">2.1 进程状态字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81-TASK-RUNNING-R%E7%8A%B6%E6%80%81"><span class="nav-text">1 可运行状态(TASK_RUNNING) R状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81-TASK-INTERRUPTIBLE-S%E7%8A%B6%E6%80%81"><span class="nav-text">2 可中断的等待状态(TASK_INTERRUPTIBLE) S状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81-TASK-UNINTERRUPTIBLE-D%E7%8A%B6%E6%80%81"><span class="nav-text">3 不可中断的等待状态(TASK_UNINTERRUPTIBLE) D状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81-TASK-STOPPED-T%E7%8A%B6%E6%80%81"><span class="nav-text">4 暂停状态(TASK_STOPPED) T状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%B7%9F%E8%B8%AA%E7%8A%B6%E6%80%81-TASK-TRACED-T%E7%8A%B6%E6%80%81"><span class="nav-text">5 跟踪状态(TASK_TRACED) T状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%83%B5%E6%AD%BB%E7%8A%B6%E6%80%81-EXIT-ZOMBIE"><span class="nav-text">6 僵死状态(EXIT_ZOMBIE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%83%B5%E6%AD%BB%E6%92%A4%E9%94%80%E7%8A%B6%E6%80%81-EXIT-DEAD"><span class="nav-text">7 僵死撤销状态(EXIT_DEAD)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AD%97%E6%AE%B5"><span class="nav-text">2.2 线程描述符字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%AD%97%E6%AE%B5"><span class="nav-text">2.3 进程调度策略字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E5%AD%97%E6%AE%B5"><span class="nav-text">2.4 进程标识字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E4%BA%B2%E5%B1%9E%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5"><span class="nav-text">2.5 亲属关系字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%BF%9B%E7%A8%8B%E7%BB%84-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%AD%97%E6%AE%B5"><span class="nav-text">2.6 进程组&#x2F;线程组字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">2.7 进程链表字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-TASK-RUNNING%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="nav-text">2.8 TASK_RUNNING状态的进程链表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xusworld</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xusworld</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
